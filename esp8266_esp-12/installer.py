
import os

def install(path='/'):
    try:
        os.stat(path+'initialized')
        return
    except:
        pass

    print('Writing',path+'/api.py')
    with open(path+'/api.py','w') as f:
        f.write('''\nimport globals\nimport logger\nimport json\nfrom http import post\nimport gc\n\nversion='v1'\n\n# Generic calls\ndef apost(api, data={}):\n    try:\n        data['token'] = globals.token\n    except AttributeError:\n        pass             \n    url = '{}/api/{}{}'.format(globals.pythings_host,version,api)\n    logger.debug('Calling API {} with data'.format(url),data) \n    response = post(url, data=data)\n    gc.collect()\n    logger.debug('Got response:',response)\n    if response['content'] :\n        response['content'] = json.loads(response['content']) \n    logger.debug('Loaded json content and returning')\n    return response\n\ndef report(what, status, message=None):\n    logger.info('Reporting "{}" as "{}" with message "{}"'.format(what,status,message))\n    response = apost('/things/report/', {'what':what,'status': status,'message': message})\n    logger.debug('Response:',response)\n''')
        f.write('''''')

    print('Writing',path+'/arch.py')
    with open(path+'/arch.py','w') as f:
        f.write('''arch = 'esp8266_esp-12'\n''')
        f.write('''''')

    print('Writing',path+'/common.py')
    with open(path+'/common.py','w') as f:
        f.write('''import time\nimport logger\n\nclass Chronos(object):\n    def __init__(self, epoch_s_now=0):\n        self.epoch_baseline_s    = epoch_s_now\n        self.internal_baseline_s = int(time.ticks_ms()/1000)\n    def epoch_s(self):\n        if self.epoch_baseline_s is not None and self.internal_baseline_s is not None:\n            current_epoch_ms = (int(time.ticks_ms()/1000) - self.internal_baseline_s) + self.epoch_baseline_s        \n            return current_epoch_ms\n        else:\n            return time.ticks_ms()/1000\n\ndef run_controlled(retr, function, **kwargs):\n    count=0\n    sleep=3\n    while True:\n        try:\n            return function(**kwargs)   \n        except Exception as e:\n            import sys\n            sys.print_exception(e)\n            logger.error('Error in executing controlled step ({}): {} {}'.format(function,e.__class__.__name__,e))\n            if retr == None or count < retr:\n                count += 1\n                logger.info('Retrying (#{}) in {} seconds...'.format(count,sleep))\n                time.sleep(sleep)\n            else:\n                logger.info('Exiting due to maximum retries reached')\n                return None\n        finally:\n            import gc\n            gc.collect()\n\ndef get_running_app_version():\n    try:\n        from app import version as app_version\n    except Exception as e:\n        import sys\n        sys.print_exception(e)\n        logger.error('Error in importing version from app ({}:{}), trying obtaining it by parsing the file'.format(type(e), str(e)))\n        try:\n            with open('/app.py','r') as file:\n                last_line=None\n                for line in file:\n                    last_line=line\n            app_version=last_line.split('=')[1].replace('\'','')\n        except Exception as e:\n            sys.print_exception(e)\n            logger.error('Error in reading version form app code ({}:{}), falling back on version 0: '.format(type(e), str(e)))\n            app_version='0'\n    return app_version\n\ndef get_running_pythings_version():\n    try:\n        from version import version\n    except Exception as e:\n        logger.error('Error in obtaining Pythings version: ({}: {}), skipping...'.format(type(e), str(e)))\n        version='Unknown'\n    return version\n''')
        f.write('''''')

    print('Writing',path+'/files.txt')
    with open(path+'/files.txt','w') as f:
        f.write('''file:880:api.py\nfile:24:arch.py\nfile:2257:common.py\nfile:394:files.txt\nfile:0:globals.py\nfile:964:hal.py\nfile:620:handle_main_error.py\nfile:3142:http.py\nfile:6579:init.py\nfile:662:logger.py\nfile:1370:main.py\nfile:3232:management.py\nfile:309:updates_app.py\nfile:1211:updates_pythings.py\nfile:682:updates_settings.py\nfile:1702:utils.py\nfile:7796:websetup.py\nfile:846:worker.py\nfile:15:version.py\n''')
        f.write('''''')

    print('Writing',path+'/globals.py')
    with open(path+'/globals.py','w') as f:
        f.write('''''')
        f.write('''''')

    print('Writing',path+'/hal.py')
    with open(path+'/hal.py','w') as f:
        f.write('''\nimport machine\nimport network\n\n# Constants (settings)\nHW_SUPPORTS_DEEPSLEEP  = True\nHW_SUPPORTS_RESETCAUSE = True\nHW_SUPPORTS_LED        = True\nHW_SUPPORTS_WLAN       = True\n\n# Required if resetcause is supported\nHARD_RESET = 6\n\ndef init():\n    # i.e. turn off extra LEDs and lower PWMs\n    pass\n\n# Objects\nclass LED(object):\n    @staticmethod\n    def on():\n        machine.Pin(2, machine.Pin.OUT).low()     \n    @staticmethod\n    def off():\n        machine.Pin(2, machine.Pin.OUT).high() \n\nclass WLAN(object):  \n    @staticmethod\n    def sta_active(mode):\n        network.WLAN(network.STA_IF).active(mode)\n    @staticmethod\n    def ap_active(mode):\n        network.WLAN(network.AP_IF).active(mode)\n\ndef get_tuuid():\n    wlan = network.WLAN(network.STA_IF)\n    mac_b = wlan.config('mac')\n    mac_s = ':'.join( [ "%02X" % x for x in mac_b ] )\n    return mac_s.replace(':','')\n\ndef reset_cause():\n    return machine.reset_cause()\n\ndef reboot():\n    machine.reset()\n''')
        f.write('''''')

    print('Writing',path+'/handle_main_error.py')
    with open(path+'/handle_main_error.py','w') as f:
        f.write('''import sys\ndef handle(e):\n    print('Error in executing Pythings framework: ',type(e), str(e))\n    sys.print_exception(e)\n    try:\n        from api import report\n        report('pythings', 'KO', e.__class__.__name__+' '+str(e))\n    except Exception as e2:\n        print('Error in reporting error to Pythings framework: ',type(e2), str(e2))\n        sys.print_exception(e2) # TODO: try except also the prints as they can fail due to uncode   \n    print('\n{}: I will reset in 5 seconds. CTRL-C now to stop the reset.'.format(e.__class__.__name__)) \n    import time\n    import machine\n    time.sleep(5)\n    machine.reset() ''')
        f.write('''''')

    print('Writing',path+'/http.py')
    with open(path+'/http.py','w') as f:
        f.write('''import socket\nimport json\nimport logger\n\n# Note: post and get will load a single line to avoid memory problems in case of error 500\n# pages and so on (Pythings backend will always provide responses in one line).\n\ndef post(url, data):\n\n    _, _, host, path = url.split('/', 3)\n    port=80\n    if ':' in host:\n        port=int(host.split(':')[1])\n        host=host.split(':')[0]\n    addr = socket.getaddrinfo(host, port)[0][-1]\n    s = socket.socket()\n    try: s.settimeout(60)\n    except: pass\n    s.connect(addr) #Tryexcept this\n    s.write('%s /%s HTTP/1.0\r\nHost: %s\r\n' % ('POST', path, host))\n\n    content = json.dumps(data)\n    content_type = 'application/json'\n\n    if content is not None:\n        s.write('content-length: %s\r\n' % len(content))\n        s.write('content-type: %s\r\n' % content_type)\n        s.write('\r\n')\n        s.write(content)\n    else:\n        s.write('\r\n')\n\n    # Status, msg etc.\n    version, status, msg = s.readline().split(None, 2)\n\n    # Skip headers\n    while s.readline() != b'\r\n':\n        pass\n\n    # Read data\n    content = None\n    while True:\n        data = s.readline()\n        if data:      \n            content = str(data, 'utf8')\n            break   \n        else:\n            break\n        \n    s.close()\n    return {'version':version, 'status':status, 'msg':msg, 'content':content}\n           \n\ndef get(url):\n    _, _, host, path = url.split('/', 3)\n    port=80\n    if ':' in host:\n        port=int(host.split(':')[1])\n        host=host.split(':')[0]\n    addr = socket.getaddrinfo(host, port)[0][-1]\n    s = socket.socket()\n    try: s.settimeout(60)\n    except: pass\n    s.connect(addr)\n    s.send(bytes('GET /%s HTTP/1.0\r\nHost: %s\r\n\r\n' % (path, host), 'utf8'))\n\n    # Status, msg etc.\n    version, status, msg = s.readline().split(None, 2)\n\n    # Skip headers\n    while s.readline() != b'\r\n':\n        pass\n\n    # Read data\n    while True:\n        data = s.readline\n        if data:\n            content = str(data, 'utf8')\n        else:\n            break\n    s.close() #TODO: add a finally for closing the connnection?\n    return {'version':version, 'status':status, 'msg':msg, 'content':content}\n\n\ndef download(source,dest):\n    logger.info('Downloading {} in {}'.format(source,dest)) \n    f = open(dest, 'w')\n    _, _, host, path = (source).split('/', 3)\n    port=80\n    if ':' in host:\n        port=int(host.split(':')[1])\n        host=host.split(':')[0]\n    addr = socket.getaddrinfo(host, port)[0][-1]\n    s = socket.socket()\n    try: s.settimeout(60)\n    except: pass\n    s.connect(addr)\n    s.send(bytes('GET /%s HTTP/1.0\r\nHost: %s\r\n\r\n' % (path, host), 'utf8'))\n \n    # Status, msg etc.\n    version, status, msg = s.readline().split(None, 2)\n\n    if status != b'200':\n        logger.error('Status {} trying to get '.format(status),source)\n        f.close()\n        s.close()\n        return False\n\n    # Skip headers\n    while s.readline() != b'\r\n': \n        pass \n\n    while True:\n        data = s.readline() #data = s.rec''')
        f.write('''v(100)?\n        if data:\n            f.write((str(data, 'utf8')))\n        else:\n            break\n    f.close()\n    s.close()\n    return True\n''')

    print('Writing',path+'/init.py')
    with open(path+'/init.py','w') as f:
        f.write('''\n#  Imports\nimport machine\nimport time\nimport gc\nimport globals\nimport common\nimport hal\nfrom utils import load_param\n\n# Logger\nimport logger\nlogger.level = logger.DEBUG\n\n#---------------------\n#  Main\n#---------------------\n\ndef start(path=None):\n\n    # Get Pythings version\n    globals.running_pythings_version = common.get_running_pythings_version()\n\n    print('|------------------------|')\n    print('|  Starting Pythings :)  |')\n    print('|------------------------|')\n    print('Version: {} (ESP8266)'.format(globals.running_pythings_version))\n\n    if hal.HW_SUPPORTS_RESETCAUSE and hal.HW_SUPPORTS_WLAN:\n        websetup_timeout = load_param('websetup_timeout', 60)\n        # Start AP config mode if required\n        if hal.reset_cause() == hal.HARD_RESET:\n            if websetup_timeout:\n                gc.collect()\n                if hal.HW_SUPPORTS_LED: hal.LED.on()\n                from websetup import websetup\n                websetup(timeout_s=websetup_timeout, lock_session=True)\n                if hal.HW_SUPPORTS_LED: hal.LED.off()\n                # Reset (will start without AP config mode since this is a soft reset)\n                logger.info('Resetting...')\n                hal.reboot()\n\n    \n    # Enable STA mode and Disable AP mode\n    if hal.HW_SUPPORTS_WLAN:\n        hal.WLAN.ap_active(False)\n        hal.WLAN.sta_active(True)\n    \n    # Start loading settings and parameters\n    from utils import load_settings\n    globals.settings = load_settings()\n\n    # Load aid and tid: only local param or default\n    globals.aid = load_param('aid', None)\n    globals.tid = load_param('tid', hal.get_tuuid())\n    \n    # Load pythings_host: the local param wins \n    globals.pythings_host = load_param('pythings_host', None)\n    if not globals.pythings_host:\n        pythings_host_overrided = False\n        if 'pythings_host' in globals.settings and globals.settings['pythings_host']:\n            globals.pythings_host = 'http://'+globals.settings['pythings_host']\n        else:\n            globals.pythings_host = 'http://backend.pythings.io'\n    else:\n        pythings_host_overrided = True\n\n    # Load pool: the local param wins \n    globals.pool = load_param('pool', None)\n    if not globals.pool:\n        if 'pool' in globals.settings and globals.settings['pool']:\n            globals.pool = globals.settings['pool']\n        else:\n            globals.pool = 'production'\n\n    # Tasks placeholders\n    globals.app_worker_task = None\n    globals.app_management_task = None\n      \n    # Report\n    logger.info('Running with pythings_host="{}" and aid="{}"'.format(globals.pythings_host, globals.aid))\n\n    # Get app version:    \n    globals.running_app_version = common.get_running_app_version()\n    gc.collect()\n\n    # Register and perform the first management task call on "safe" backend\n    if not pythings_host_overrided:\n        pythings_host_set = globals.pythings_host\n        globals.pythings_host ='http://backend.pythings.io'\n    \n    # Register yourself, and start a ne''')
        f.write('''w session\n    from api import apost\n    logger.info('Registering myself with tid={} and aid={}'.format(globals.tid,globals.aid))\n    response = common.run_controlled(None,\n                                     apost,\n                                     api='/things/register/',\n                                     data={'tid':globals.tid,\n                                           'aid': globals.aid,\n                                           'running_app_version': globals.running_app_version,\n                                           'running_pythings_version': globals.running_pythings_version,\n                                           'pool': globals.pool,\n                                           'settings': globals.settings})\n    if not response:\n        class EmptyResponse(Exception):\n            pass\n        raise EmptyResponse()\n    \n    globals.token = response['content']['data']['token']\n    logger.info('Got token: {}'.format(globals.token))\n    \n    # Sync time.\n    epoch_s = response['content']['data']['epoch_s']\n    chronos = common.Chronos(epoch_s)\n    del response\n    gc.collect()\n\n    # Call system management (will update App/Pythings versions  and settings if required)\n    gc.collect()\n    logger.info('Calling system management (preloop)')\n\n    from management import system_management_task\n    system_management_task(chronos)\n    del system_management_task\n    gc.collect()\n    \n    # Set back host to the proper one\n    if not pythings_host_overrided:\n        globals.pythings_host=pythings_host_set\n        del pythings_host_set\n    gc.collect()\n\n    # Init app\n    try:\n        from app import worker_task\n        globals.app_worker_task = worker_task(chronos)\n    except Exception as e:\n        import sys\n        from api import report\n        sys.print_exception(e)\n        logger.error('Error in importing/loading app\'s worker tasks: {} {}'.format(e.__class__.__name__, e))\n        common.run_controlled(2,report,what='worker', status='KO', message='{} {}'.format(e.__class__.__name__, e))\n\n    try:\n        from app import management_task\n        globals.app_management_task = management_task(chronos)\n    except Exception as e:\n        import sys\n        from api import report\n        sys.print_exception(e)\n        logger.error('Error in importing/loading  app\'s management tasks: {} {}'.format(e.__class__.__name__, e))\n        common.run_controlled(2,report,what='worker', status='KO', message='{} {}'.format(e.__class__.__name__, e))\n\n    # Setup intervals\n    worker_interval = int(globals.settings['worker_interval']) if 'worker_interval' in globals.settings else 300\n    management_interval = int(globals.settings['management_interval']) if 'management_interval' in globals.settings else 60\n\n    # Start main loop\n    loop_count = 0\n    while True:\n        \n        if loop_count % management_interval == 0:\n            logger.info('Calling management (loop={})'.format(loop_count))\n            if hal.HW_SUPPORTS_LED:\n                hal.LED.on(); time.sleep(0.05); hal.LED.off()\n            from management import system_management_task\n            system_management_task(chronos)\n            del system_management_task\n            gc.collect()\n\n        if loop_count % worker_interval == 0:\n            logger.info('Calling worker (loop={})'.format(loop_count))\n            from worker import system_worker_task\n            system_worker_task(chronos)\n            del system_worker_task\n            gc.collect()\n            \n        loop_count+=1\n        time.sleep(1)\n\n\nif __name__ == "__main__":\n    start()\n\n\n\n\n\n\n\n\n''')

    print('Writing',path+'/logger.py')
    with open(path+'/logger.py','w') as f:
        f.write('''\nDEBUG = 10\nINFO = 20\nWARNING =  30\nERROR = 40\nCRITICAL= 50\n\nlevel = INFO\n\ndef emit(level,msg, det):\n        print('{}: '.format(level), end='')\n        print(msg, end='')\n        print(' ', end='')\n        print(det, end='')\n        print('')  \n\ndef debug(msg,det=''):\n    if level <= DEBUG:\n        emit('DEBUG',msg,det) \n  \ndef info(msg,det=''):\n    if level <= INFO: \n        emit('INFO',msg,det) \n    \ndef warning(msg,det=''):\n    if level <= WARNING: \n        emit('WARNING',msg,det) \n\ndef error(msg,det=''):\n    if level <= ERROR: \n        emit('ERROR',msg,det) \n\ndef critical(msg,det=''):\n    if level <= CRITICAL: \n        emit('CRITICAL',msg,det) \n\n\n\n\n''')
        f.write('''''')

    print('Writing',path+'/main.py')
    with open(path+'/main.py','w') as f:
        f.write('''import gc\nimport os\nimport sys\nsys.path.append('/')\nfrom utils import load_settings\ntry:\n    pythings_version = load_settings()['pythings_version']\n    if not pythings_version.upper() == 'FACTORY':\n        print('Trying to load Pythings version {}'.format(pythings_version))\n        path = '/'+pythings_version\n        try:\n            os.stat(path)\n        except OSError:\n            print('No valid installation found for this version, proceeding with factory default version...')\n            path='/'\n        else:\n            print('Updated version found, checking its consistency...')\n            try:\n                os.stat(path+'/version.py')\n            except OSError:\n                print('Error, proceeding with factory default version...')\n                path='/'\n            else:\n                print('Valid updated version found.')\n                sys.path.append(path)\n                os.chdir(path)\n    else:\n        path='/'\n\nexcept Exception as e:\n    import sys\n    sys.print_exception(e)\n    print('Error, proceeding with factory defaults: ',type(e), str(e))\n    path='/'\n\ndel load_settings\n\n        \n# Execute Pythings framework\ntry:\n    import init\n    gc.collect()\n    init.start(path=path)\n\nexcept Exception as e:\n    import handle_main_error\n    handle_main_error.handle(e) # Fallback on factory defaults?\nfinally:\n    os.chdir('/')\n    \n\n''')
        f.write('''''')

    print('Writing',path+'/management.py')
    with open(path+'/management.py','w') as f:
        f.write('''import globals\nimport logger\nfrom api import apost, report\nimport gc\nfrom common import run_controlled\n\ndef system_management_task(chronos):\n    \n    updates=False\n    \n    # Call management API\n    response = run_controlled(2,apost,api='/apps/management/')\n    if response and 'content' in response: \n        content = response['content']\n    else:\n        logger.error('Error in receiving/parsing settings, skipping the rest of the management task!')\n        return\n    del response\n    gc.collect()\n\n    # Update settings, pythings, app. TODO: move to try/except?\n    try:\n        if 'settings' in content['data'] and content['data']['settings'] != globals.settings:   \n            from updates_settings import update_settings\n            if update_settings(content): updates='settings' \n        \n        elif globals.settings['pythings_version'].upper() != 'FACTORY' and globals.settings['pythings_version'] != globals.running_pythings_version:\n            logger.debug('Downloading the new pythings (running version = "{}"; required version = "{}")'.format(globals.running_pythings_version, globals.settings['pythings_version']))\n            from updates_pythings import update_pythings\n            if update_pythings(globals.settings['pythings_version']): updates='pythings' \n \n        else:\n            if globals.settings['app_version'] != globals.running_app_version:\n                logger.debug('Downloading the new app (running version = "{}"; required version = "{}")'.format(globals.running_app_version, globals.settings['app_version']))\n                from updates_app import update_app\n                if update_app(globals.settings['app_version']): updates='app'  \n\n    except Exception as e:\n        import sys\n        sys.print_exception(e)\n        logger.error('Error in checking/updating {} ({}: {}), skipping the rest...'.format(updates,type(e), e))\n        return False\n\n    gc.collect()\n\n    # If updates, reboot.\n    if updates:\n        logger.info('Rebooting due to update')\n        run_controlled(2,report,what='pythings', status='OK', message='Resetting due to {} update'.format(updates))\n        import hal\n        hal.reboot()\n\n    # Data = remote command sent, here we use a sample\n    app_data     = content['data']['app_data'] if 'app_data' in content['data'] else None\n    app_data_id  = content['data']['app_data_id'] if 'app_data_id' in content['data'] else None\n    app_data_rep = None\n\n    # Call App's management\n    if globals.app_management_task:\n        try:\n            print('67----------------------------',gc.mem_free())\n            app_data_rep=globals.app_management_task.call(chronos, app_data)\n            if app_data_id:\n                run_controlled(2,report,what='management', status='OK', message={'app_data_id':app_data_id,'app_data_rep':app_data_rep})\n            else:\n                run_controlled(2,report,what='management', status='OK')\n                \n        except Exception as e:\n            import sys\n            sys.print_excepti''')
        f.write('''on(e)\n            logger.error('Error in executing app\'s management task: {} {}'.format(e.__class__.__name__, e))\n            run_controlled(2,report,what='management', status='KO', message='{} {}'.format(e.__class__.__name__, e))\n''')

    print('Writing',path+'/test.py')
    with open(path+'/test.py','w') as f:
        f.write('''import installer\ninstaller.install('/tmp/pythest')\n''')
        f.write('''''')

    print('Writing',path+'/updates_app.py')
    with open(path+'/updates_app.py','w') as f:
        f.write('''import globals\nimport logger\nfrom utils import mv\nfrom http import download\n\ndef update_app(version):\n    try:\n        mv('/app.py','/app_bk.py')\n        if not download('{}/api/v1/apps/get/?version={}&token={}'.format(globals.pythings_host, version, globals.token), '/app.py'):  return False\n        logger.info('Got new, updated app')\n        return True\n    except:\n        return False''')
        f.write('''''')

    print('Writing',path+'/updates_pythings.py')
    with open(path+'/updates_pythings.py','w') as f:
        f.write('''\nimport globals\nimport logger\nimport os\nfrom arch import arch\n\ndef update_pythings(version):\n    source='http://backend.pythings.io/static/dist/PythingsOS/{}/{}'.format(version,arch)\n    path='/'+version\n    try:\n        os.mkdir(path)\n    except OSError as e:\n        pass\n    from http import download\n    if not download(source+'/files.txt', path+'/files.txt'):\n        return False\n    files_list = open(path+'/files.txt')\n    for item in files_list.read().split('\n'):\n        if 'file:' in item:\n            filename=item.split(':')[2]\n            if filename=='app.py': continue\n            filesize=item.split(':')[1]\n            download(source+'/'+filename, path+'/'+filename)\n            if os.stat(path+'/'+filename)[6] != int(filesize):\n                logger.error('Aborting: file expected size={}, actual size={}.'.format(filesize,os.stat(path+'/'+filename)[6]))\n                os.remove(path+'/'+filename)\n                files_list.close()\n                return False\n        else:\n            if len(item)>0:\n                logger.error('Aborting: Got unexpected format in files list.')\n                files_list.close()\n                return False\n    files_list.close()\n    return True\n''')
        f.write('''''')

    print('Writing',path+'/updates_settings.py')
    with open(path+'/updates_settings.py','w') as f:
        f.write('''\nimport globals\nimport logger\n\ndef update_settings(content):\n    try:\n        logger.debug('Storing received settings ({} <--> {})'.format(content['data']['settings'], globals.settings))\n        # TODO: Try load contents to validate?\n        # Save backup for the settings file:\n        from utils import mv\n        mv('/settings.json','/settings_bk.json')\n        # Ok, dump new settings\n        f = open('/settings.json', 'w')\n        import json\n        f.write(json.dumps(content['data']['settings']))\n        f.close()\n        globals.settings = content['data']['settings']\n        logger.info('Got new, updated settings')\n        return True\n    except:\n        return False\n\n''')
        f.write('''''')

    print('Writing',path+'/utils.py')
    with open(path+'/utils.py','w') as f:
        f.write('''import os\nimport ure\n\ndef connect_wifi(wlan, essid, password):\n    print("Connecting with: ", essid)\n    print("Using password: ", password)\n    wlan.connect(essid, password)\n\ndef unquote(s):\n    res = s.split('%')\n    for i in range(1, len(res)): # no xrange as not available for this micro.\n        item = res[i]\n        try:\n            res[i] = chr(int(item[:2], 16)) + item[2:]\n        except ValueError:\n            res[i] = '%' + item\n    return "".join(res)\n\ndef load_param(param, default=None):\n    try:\n        with open('/{}'.format(param),'r') as f:\n            param = f.readline()\n        return param\n    except Exception as e:\n        return default\n\ndef load_settings():\n    import json\n    settings = {}\n    try:\n        with open('/settings.json','r') as f:\n            settings = json.loads(f.read())\n    except Exception as e:\n        print('Cannot open settings.py and load the json content: {}'.format(e))\n    return settings\n\ndef mv(source,dest):\n    try:\n        import os\n        try:\n            os.remove(dest)\n        except:\n            pass\n        os.rename(source, dest)\n    except:\n        pass\n\n\n\ndef get_wifi_data():\n    try:\n        with open('/wifi','r') as f:\n            essid = f.readline()[0:-1]\n            password = f.readline()\n    except:\n        essid=None\n        password=None\n    return (essid,password)\n\ndef parseURL(url):\n    parameters = {}\n    path = ure.search("(.*?)(\?|$)", url).group(1)\n    if '?' in url:\n        try:\n            for keyvalue in url.split('?')[1].split('&'):\n                parameters[unquote(keyvalue.split('=')[0])] = unquote(keyvalue.split('=')[1])\n        except IndexError:\n            pass\n    return path, parameters\n''')
        f.write('''''')

    print('Writing',path+'/version.py')
    with open(path+'/version.py','w') as f:
        f.write('''version='v0.1'\n''')
        f.write('''''')

    print('Writing',path+'/websetup.py')
    with open(path+'/websetup.py','w') as f:
        f.write('''\nimport network\nimport socket\nimport time\nimport machine\nimport logger\nimport json\nimport ure\nimport gc\n\nfrom utils import *\nfrom hal import get_tuuid\n\ndef websetup(timeout_s=60, lock_session=False):\n    logger.info('Starting WebSetup')\n    addr = socket.getaddrinfo('0.0.0.0', 80)[0][-1]\n    s = socket.socket()\n    s.bind(addr)\n    s.listen(0)\n    s.settimeout(timeout_s)\n    logger.info('Listening on ', addr)\n    CONF_PAGE_ACCESSED = False\n    \n    # Start AP mode and disable client mode\n    sta = network.WLAN(network.STA_IF)\n    sta.active(False)\n    ap = network.WLAN(network.AP_IF)\n    ap.active(True)\n    ap.config(essid="Device_{}".format(get_tuuid()), authmode=network.AUTH_WPA_WPA2_PSK, password="NewDevice")\n    \n    while True:\n        try:\n            logger.info('Waiting for a connection..')\n            gc.collect\n            \n            # Handle client connection\n            cl, addr = s.accept()\n            logger.info('Client connected from ', addr)\n            if lock_session:\n                s.settimeout(None)\n            CONF_PAGE_ACCESSED = True\n\n            # Read request\n            request = str(cl.recv(1024))\n\n            # Parse GET request\n            get_request_data = ure.search("GET (.*?) HTTP\/1\.1", request)\n            if get_request_data:\n                path, parameters = parseURL(get_request_data.group(1))\n                logger.debug('Got request for path = "{}" with params = "{}"'.format(path, parameters))\n            else:\n                path = []\n                parameters = []\n\n            cl.write('HTTP/1.0 200 OK\r\n')\n            cl.write('Access-Control-Allow-Methods: POST, GET, OPTIONS\r\n');\n            cl.write("Access-Control-Allow-Origin: *\r\n");\n            #cl.write('Access-Control-Allow-Origin: http://localhost:8080\n');\n            cl.write("Access-Control-Allow-Credentials: true\r\n");\n            cl.write("Access-Control-Allow-Headers: X-CSRFToken, ACCEPT, CONTENT-TYPE, X-CSRF-TOKEN, Content-Type, Authorization, X-Requested-With\r\n");\n\n            if not get_request_data: # an OPTIONS, basically\n                logger.debug('no GET data in request')\n                cl.write('Content-Length: 0\r\n\r\n')\n                cl.close()\n                continue\n            def set_api():\n                cl.write('Content-Type: application/json\r\n')\n                cl.write('\r\n')\n            def set_page():\n                cl.write('Content-Type: text/html\r\n')\n                cl.write('\r\n')\n\n            # Close connection if requesting favicon\n            if 'favicon' in path:\n                logger.debug('Requested favicon, closing connection')\n                set_api()\n                cl.close()\n            \n            # This is an API call\n            elif 'cmd' in parameters:\n                logger.debug('Called API with cmd={}'.format(parameters['cmd']))\n                set_api()\n                cmd = parameters['cmd']\n                essid = None\n                if 'essid' in parameters: e''')
        f.write('''ssid = parameters['essid']   \n                password = None\n                if 'password' in parameters: password = parameters['password']                    \n                try:\n                    LED = machine.Pin(2, machine.Pin.OUT)  \n                    LED.high()\n                    time.sleep(0.3)\n                    LED.low()\n                except:\n                    pass\n                gc.collect()\n\n                # Set app command\n                if cmd=='set_app':\n                    logger.debug('Called set app API')\n                    aid = None\n                    aid = parameters['aid']\n                    if aid is None:\n                        cl.write(json.dumps({'status':'ERROR'}))\n                    else:\n                        with open('/aid','w') as f:\n                            f.write(aid)\n                    cl.write(json.dumps({'status':'OK', 'aid': load_param('aid',None)}))\n\n                # Check command\n                if cmd=='check':\n                    import os\n                    logger.debug('Called check API')\n                    cl.write(json.dumps({'status':'OK', 'info': str(os.uname().version),'aid':load_param('aid',None)}))\n                \n                # Check_wifi command\n                if cmd=='check_wifi':\n                    logger.debug('Called check_wifi API')\n                    sta.active(True)\n                    essid='Unknown'\n                    isconnected=False\n                    essid,password = get_wifi_data()\n                    if essid:\n                        connect_wifi(sta, essid, password)\n                        time.sleep(25)\n                    isconnected = sta.isconnected()\n                    sta.active(False) \n                    cl.write(json.dumps({'status':'OK', 'isconnected':isconnected, 'essid':essid}))\n                \n                # Scan command\n                elif cmd == 'scan':\n                    logger.debug('Called scan API')\n                    sta.active(True)\n                    nets = sta.scan() \n                    sta.active(False)\n                    cl.write(json.dumps(nets))\n                          \n                # Join command                  \n                elif cmd == 'join':\n                    logger.debug('Called join API')\n                    if password is None or essid is None:\n                        cl.write(json.dumps({'status': 'ERROR'}))\n                    else:\n                        sta.active(True)\n                        connect_wifi(sta, essid, password)\n                        time.sleep(25)\n                        isconnected = sta.isconnected()\n                        saved = False\n                        if isconnected:\n                            try:\n                                with open('/wifi','w') as f:\n                                    f.write('{}\n{}'.format(essid,password))\n                                saved=True\n                            except:\n                                saved=False\n                        sta.active(False)\n                        cl.write(json.dumps({'status':'OK', 'isconnected':isconnected, 'essid':essid, 'saved':saved}))\n                \n                # Close command\n                elif cmd == 'close':\n                    logger.debug('Called close API')\n                    cl.write(json.dumps({'status': 'OK'}))\n                    cl.close()\n                    s.close()\n                    break\n\n            #elif 'jquery' in path:\n            #    logger.debug('Serving jquery')\n            #    set_page()\n            #    with open('/jquery.js') as f:\n            #        for line in f:\n            #            cl.write(line)\n\n            else:\n                logger.debug('Serving main page')\n                set_page()\n                cl.write('Please go to your vendor\'s Website to configure this device.\r\n')\n                #with open('websetup.html') as f:\n                #    for line in f:\n                #        cl.write(line)\n\n            # Close client connection at the end\n            logger.info('Closing client connection')\n            cl.close()\n        \n        except OSError as e:\n            if str(e) == "[Errno 110] ETIMEDOUT":\n                if CONF_PAGE_ACCESSED:\n                    #continue\n                    logger.info('Exiting due to no activity')\n                    s.close()\n                    break\n                \n                else:\n                    logger.info('Exiting due to no incoming connections')\n                    s.close()\n                    break\n            import sys\n            sys.print_exception(e)\n            logger.error(str(e))\n            try: cl.close()\n            except: pass\n            try: s.close()\n            except: pass\n            time.sleep(3)\n''')

    print('Writing',path+'/worker.py')
    with open(path+'/worker.py','w') as f:
        f.write('''import globals\nimport logger\nfrom api import apost, report\nimport gc\nfrom common import run_controlled\n\ndef system_worker_task(chronos):\n    \n    # Call App's worker    \n    if globals.app_worker_task:\n        app_data = None\n        try:\n            print('97----------------------------',gc.mem_free())\n            app_data = globals.app_worker_task.call(chronos)\n            if app_data:\n                run_controlled(2,apost,api='/msg/drop/', data={'msg': app_data })\n            report('worker','OK')\n        except Exception as e:\n            import sys\n            sys.print_exception(e)\n            logger.error('Error in executing app\'s worker taks or sending its data: {} {}'.format(e.__class__.__name__, e))\n            run_controlled(2,report,what='worker', status='KO', message='{} {}'.format(e.__class__.__name__, e))\n            ''')
        f.write('''''')

        with open(path+'/initialized','w') as f:
            f.write('')
        
            
    